#!/usr/bin/env python3

import argparse, configparser
import sys, os, shutil, subprocess
import zipfile

class AddonBuilder:
	'''
	'''
	# subclasses
	class project:
		pass
	# initialization
	def __init__(self):
		# get paths
		self.cwd = os.getcwd()
		self.pyFilePath = os.path.dirname(os.path.realpath(__file__))
		# check for a project folder
		for entry in os.scandir(os.path.join(self.pyFilePath, "..")):
			if entry.is_dir() and entry.name[0] == "@":
				self.project.name = entry.name[1:]
		# get command line arguments
		self.parser = argparse.ArgumentParser(description="Packs PBOs")
		if not hasattr(self.project, "name"):
			# get the project name as an argument if none was found
			self.parser.add_argument("project", help="Name of the project to pack.")
		self.parser.add_argument("version", nargs="?", default="dev", help="(optional) Version of the project to pack. Default is \"dev\".")
		self.parser.add_argument("-c","--configure", action="store_true", help="If this flag is present, the configuration for the project is opened.")
		self.parser.add_argument("-d","--discord", action="store_true", help="If this flag is present, the project is posted on discord as a zip.")
		self.parser.add_argument("-r","--release", action="store_true", help="If this flag is present, the project is released on GitHub.")
		self.args = self.parser.parse_args()
		# get project attributes
		if not hasattr(self.project, "name"):
			self.project.name = self.args.project
		self.project.version = self.args.version
		# config init
		self.config =  configparser.ConfigParser()
		self.config.path = os.path.join(self.pyFilePath, "AddonBuilder.ini")
		# run the builder
		self.procs = []
		if self.args.configure:
			# open configurations if -s flag is present
			self.configurations()
		else:
			# pack the add-on otherwise
			self.load()
			self.pack()
	# methods
	def configurations(self):
		'''
		Opens the configurations interface for the project
		'''
		try:
			self.config.read(self.config.path)
			self.config[self.project.name]
		except KeyError:
			print("Generating a new configuration...")
			try:
				while True:
					self.steamFolderPath = input("Enter the path to your Steam folder:\n")
					if os.path.isdir(self.steamFolderPath):
						break
					else:
						print("Error: Your given path was invalid!")
						continue
			except KeyboardInterrupt:
				print("Cancled!")
				sys.exit(1)
			with open(self.config.path, "a") as configStream:
				configStream.write("# Warning: This file was generated automatically!\n")
				configStream.write("# Warning: The folder paths may have to be corrected!\n")
				configStream.write("[{}]\n".format(self.project.name))
				configStream.write("# Path to the AddonBuilder executable from the ArmA 3 Tools\n")
				configStream.write("exePath = {}\n".format(os.path.join(self.steamFolderPath, "steamapps", "common", "Arma 3 Tools", "AddonBuilder", "AddonBuilder.exe")))
				configStream.write("# Path to the DsSignFile folder from the ArmA 3 Tools\n")
				configStream.write("dsSignFileFolderPath = {}\n".format(os.path.join(self.steamFolderPath, "steamapps", "common", "Arma 3 Tools", "DSSignFile")))
				configStream.write("# Path to the @{} folder\n".format(self.project.name))
				configStream.write("projectFolderPath = {}\n".format(os.path.join(self.steamFolderPath, "steamapps", "common", "Arma 3", "@" + self.project.name)))
				configStream.write("# The prefix for the PBO paths. The path to the root of the PBO will be pboPrefix\\pboName. A substitute is available: {0} for the project name\n")
				configStream.write("pboPrefix = {0}\n")
				configStream.write("# Name for the bikey file. Two substitutes are available: {0} for the project name and {1} for the version\n")
				configStream.write("bikeyFormatted = {0}_{1}\n")
				configStream.write("# Path to the bikey folder. A new key is generated if it does not exist in there.\n")
				configStream.write("bikeyFolderPath = {}\n".format(os.path.join(self.steamFolderPath, "steamapps", "common", "Arma 3", "@" + self.project.name, "keys")))
				configStream.write("# Path to the biprivatekey folder. A new key is generated if it does not exist in there.\n")
				configStream.write("biprivatekeyFolderPath = {}\n".format(os.path.join(self.steamFolderPath, "steamapps", "common", "Arma 3 Tools", "DSSignFile", "privateKeys")))
		print("Open configurations of", self.project.name)
		if sys.platform.startswith("darwin"):
			subprocess.call(["open", self.config.path])
		elif os.name == "nt":
			os.startfile(self.config.path)
		elif os.name == "posix":
			subprocess.call(("xdg-open", self.config.path))
	
	def load(self):
		'''
		Loads configurations of the project
		'''
		# check config
		try:
			self.config.read(self.config.path)
			self.config[self.project.name]
		except KeyError:
			sys.stderr.write("Error: You have to configure your project first!\nTherefore, use the -s flag.")
			sys.exit(1)
		# read from config
		self.exePath = self.config[self.project.name]["exePath"]
		self.dsSignFileFolderPath = self.config[self.project.name]["dsSignFileFolderPath"]
		self.project.folderPath = self.config[self.project.name]["projectFolderPath"]
		self.project.pboFolderPath = os.path.join(self.project.folderPath, "addons")
		self.project.pboPrefixFormatted = self.config[self.project.name]["pboPrefix"]
		self.project.pboPrefix = self.project.pboPrefixFormatted.format(self.project.name)
		self.project.bikeyFormatted = self.config[self.project.name]["bikeyFormatted"]
		self.project.bikeyName = self.project.bikeyFormatted.format(self.project.name, self.project.version)
		self.project.bikeyFolderPath = self.config[self.project.name]["bikeyFolderPath"]
		self.project.bikeyPath = os.path.join(self.project.bikeyFolderPath, self.project.bikeyName + ".bikey")
		self.project.biprivatekeyFolderPath = self.config[self.project.name]["biprivatekeyFolderPath"]
		self.project.biprivatekeyPath = os.path.join(self.project.biprivatekeyFolderPath, self.project.bikeyName + ".biprivatekey")
		# check if folder paths are valid
		for path in [self.dsSignFileFolderPath, self.project.folderPath, self.project.bikeyFolderPath, self.project.biprivatekeyFolderPath]:
			if not os.path.isdir(path):
				sys.stderr.write("Error: {} does not exist!".format(path))
				sys.exit(1)
		# check if file paths are valid
		for path in [self.exePath]:
			if not os.path.isfile(path):
				sys.stderr.write("Error: {} does not exist!".format(path))
				sys.exit(1)
	
	def pack(self):
		'''
		Packs the project
		'''
		print("Packing", self.project.name, self.project.version, "...")
		self.genBikey()
		for entry in os.scandir(self.project.pboFolderPath):
			if entry.is_dir():
				proc = subprocess.Popen('{} "{}" "{}" -sign="{}" -prefix="{}" "-packonly" "-binarizeFullLogs"'.format(self.exePath, entry.path, self.project.pboFolderPath, self.project.biprivatekeyPath, os.path.join(self.project.pboPrefix, entry.name)), creationflags=subprocess.CREATE_NEW_CONSOLE)
				self.procs.append(proc)
		exitCodes = [proc.wait() for proc in self.procs]
		if 1 in exitCodes:
			sys.stderr.write("Error: AddonBuilder could not pack PBOs!\nEither the paths are wrong or Steam is not running.\n")
			sys.exit(1)
		self.procs = []
		print("Packing completed!")
	
	def genBikey(self):
		'''
		Creates a bikey if it was not already created
		'''
		if not os.path.isfile(self.project.biprivatekeyPath):
			print("Generating", self.project.bikeyName + ".bikey", "...")
			os.chdir(self.project.biprivatekeyFolderPath)
			subprocess.check_call([os.path.join(self.dsSignFileFolderPath, "DSCreateKey.exe"), self.project.bikeyName])
			shutil.move(os.path.join(self.project.biprivatekeyFolderPath, self.project.bikeyName + ".bikey"), self.project.bikeyPath)
			os.chdir(self.cwd)
			print("Bikey generated!")
	
	def postOnDiscord(self, channel, message):
		'''
		Posts the project as a zip-file on Discord
		'''
		pass
	
	def release(self):
		'''
		Releases the project on GitHub
		'''
		pass

if __name__ == "__main__":
	AddonBuilder()
