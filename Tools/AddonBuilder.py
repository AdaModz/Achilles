#!/usr/bin/env python3

import argparse, configparser
import sys, os, shutil, subprocess
import zipfile

class AddonBuilder:
	'''
	Was tested on Windows and Cygwin
	'''
	# subclasses
	class project:
		pass
	class procs:
		list = []
		outputs = []
	class discord:
		pass
	class github:
		pass
	class workshop:
		pass
	# initialization
	def __init__(self):
		# get paths
		self.cwd = os.getcwd()
		self.pyFilePath = os.path.dirname(os.path.realpath(__file__))
		# check for a project folder
		for entry in os.scandir(os.path.join(self.pyFilePath, "..")):
			if entry.is_dir() and entry.name[0] == "@":
				self.project.name = entry.name[1:]
		# get command line arguments
		self.parser = argparse.ArgumentParser(description="Packs PBOs")
		if not hasattr(self.project, "name"):
			# get the project name as an argument if none was found
			self.parser.add_argument("project", help="Name of the project to pack.")
		self.parser.add_argument("version", nargs="?", default="dev", help="(optional) Version of the project to pack. Default is \"dev\".")
		self.parser.add_argument("-c","--configure", action="store_true", help="If this flag is present, the configuration for the project is opened.")
		self.parser.add_argument("-d","--discord", action="store_true", help="If this flag is present, the project is posted on discord as a zip.")
		self.parser.add_argument("-r","--release", action="store_true", help="If this flag is present, the project is released on GitHub.")
		self.args = self.parser.parse_args()
		# get project attributes
		if not hasattr(self.project, "name"):
			self.project.name = self.args.project
		self.project.version = self.args.version
		# config init
		self.config =  configparser.ConfigParser()
		self.config.path = os.path.join(self.pyFilePath, "AddonBuilder.ini")
		# run the builder
		self.procs.list = []
		if self.args.configure:
			# open configurations if -c flag is present
			self.configuration()
		else:
			# pack the add-on otherwise
			self.load()
			self.pack()
	# methods
	def configuration(self):
		'''
		Opens the configurations interface for the project
		'''
		# check if a config for the rpject exist
		try:
			self.config.read(self.config.path)
			self.config[self.project.name]
		except KeyError:
			print("Generating a new configuration...")
			self.steamFolderPath = None
			if os.name == "nt":
				# search for steam folder in windows registry
				import winreg
				try:
					reg = winreg.ConnectRegistry(None, winreg.HKEY_CURRENT_USER)
					entries = winreg.OpenKey(reg, r"Software\Valve\Steam")
					self.steamFolderPath = winreg.QueryValueEx(entries, "SteamPath")[0]
					self.steamFolderPath = self.steamFolderPath.replace("/", os.path.sep)
				except FileNotFoundError:
					pass
			elif os.name == "posix":
				# check if the default path is valid on Linux
				if os.path.isfile("~/.local/share/Steam"):
					self.steamFolderPath = "~/.local/share/Steam"
			if not self.steamFolderPath:
				# if steam folder path was not found, then ask the user
				try:
					while True:
						self.steamFolderPath = input("Enter the path to your Steam folder:\n")
						if os.path.isdir(self.steamFolderPath):
							break
						else:
							print("Error: Your given path was invalid!")
							continue
				except KeyboardInterrupt:
					print("Canceled!")
					sys.exit(1)
			# generate a provisional config file
			with open(self.config.path, "a") as configStream:
				configStream.write("# Warning: This file was generated automatically!\n")
				configStream.write("# Warning: The folder paths may have to be corrected!\n")
				configStream.write("[{}]\n".format(self.project.name))
				configStream.write("# Path to the ArmA 3 Tools folder\n")
				configStream.write("toolsPath = {}\n".format(os.path.join(self.steamFolderPath, "steamapps", "common", "Arma 3 Tools")))
				configStream.write("# Path to the @{} folder\n".format(self.project.name))
				configStream.write("projectFolderPath = {}\n".format(os.path.join(self.steamFolderPath, "steamapps", "common", "Arma 3", "@" + self.project.name)))
				configStream.write("# The prefix for the PBO paths. The path to the root of the PBO will be pboPrefix\\pboName. A substitute is available: {0} for the project name\n")
				configStream.write("pboPrefix = {0}\n")
				configStream.write("# Name for the bikey file. Two substitutes are available: {0} for the project name and {1} for the version\n")
				configStream.write("bikeyFormatted = {0}_{1}\n")
				configStream.write("# Path to the bikey folder. A new key is generated if it does not exist in there.\n")
				configStream.write("bikeyFolderPath = {}\n".format(os.path.join(self.steamFolderPath, "steamapps", "common", "Arma 3", "@" + self.project.name, "keys")))
				configStream.write("# Path to the biprivatekey folder. A new key is generated if it does not exist in there.\n")
				configStream.write("biprivatekeyFolderPath = {}\n".format(os.path.join(self.steamFolderPath, "steamapps", "common", "Arma 3 Tools", "DSSignFile", "privateKeys")))
		# open the config file
		print("Open configurations of", self.project.name)
		if sys.platform.startswith("darwin"):
			subprocess.call(["open", self.config.path])
		elif os.name == "nt":
			os.startfile(self.config.path)
		elif sys.platform.startswith("Linux"):
			subprocess.call(["xdg-open", self.config.path])
		elif sys.platform.startswith("msys") or sys.platform.startswith("cygwin"):
			subprocess.call(["cygstart", self.config.path])
	
	def load(self):
		'''
		Loads configurations of the project
		'''
		# check config
		try:
			self.config.read(self.config.path)
			self.config[self.project.name]
		except KeyError:
			sys.stderr.write("Error: You have to configure your project first!\n")
			self.configuration()
			sys.stderr.write("AddonBuilder canceled!\n")
			sys.exit(1)
		# read from config
		self.toolsPath = self.config[self.project.name]["toolsPath"]
		self.exePath = os.path.join(self.toolsPath, "AddonBuilder", "AddonBuilder.exe")
		self.DSCreateKeyPath = os.path.join(self.toolsPath, "DSSignFile", "DSCreateKey.exe")
		self.project.folderPath = self.config[self.project.name]["projectFolderPath"]
		self.project.pboFolderPath = os.path.join(self.project.folderPath, "addons")
		self.project.pboPrefixFormatted = self.config[self.project.name]["pboPrefix"]
		self.project.pboPrefix = self.project.pboPrefixFormatted.format(self.project.name)
		self.project.bikeyFormatted = self.config[self.project.name]["bikeyFormatted"]
		self.project.bikeyName = self.project.bikeyFormatted.format(self.project.name, self.project.version)
		self.project.bikeyFolderPath = self.config[self.project.name]["bikeyFolderPath"]
		self.project.bikeyPath = os.path.join(self.project.bikeyFolderPath, self.project.bikeyName + ".bikey")
		self.project.biprivatekeyFolderPath = self.config[self.project.name]["biprivatekeyFolderPath"]
		self.project.biprivatekeyPath = os.path.join(self.project.biprivatekeyFolderPath, self.project.bikeyName + ".biprivatekey")
		# check if folder paths are valid
		for path in [self.project.folderPath, self.project.bikeyFolderPath, self.project.biprivatekeyFolderPath]:
			if not os.path.isdir(path):
				sys.stderr.write("Error: {} does not exist!".format(path))
				sys.exit(1)
		# check if file paths are valid
		for path in [self.exePath, self.DSCreateKeyPath]:
			if not os.path.isfile(path):
				sys.stderr.write("Error: {} does not exist!".format(path))
				sys.exit(1)
	
	def pack(self):
		'''
		Packs the project
		'''
		# generate a bikey if needed
		self.genBikey()
		# pack folders
		print("Packing", self.project.name, self.project.version, "...")
		for entry in os.scandir(self.project.pboFolderPath):
			if entry.is_dir():
				proc = subprocess.Popen('"{}" "{}" "{}" -sign="{}" -prefix="{}" "-packonly" "-binarizeFullLogs"'.format(self.exePath, entry.path, self.project.pboFolderPath, self.project.biprivatekeyPath, os.path.join(self.project.pboPrefix, entry.name)), shell=True, stderr=subprocess.STDOUT, stdout=subprocess.PIPE)
				self.procs.list.append(proc)
		# wait for all subprocs
		for proc in self.procs.list:
			proc.wait()
		# print error messages
		self.procs.outputs = [proc.stdout.read().decode("UTF-8") for proc in self.procs.list]
		for output in self.procs.outputs:
			for line in output.split("\n"):
				messageType = line[27:32]
				if os.name == "posix":
					# use ANSI red for stderr
					line = "\033[01;31m" + line + "\033[0m"
				if messageType == "ERROR":
					sys.stderr.write(line + "\n")
				elif messageType == "FATAL":
					sys.stderr.write(line + "\n")
					sys.exit(1)
		print("Packing completed!")
	
	def genBikey(self):
		'''
		Creates a bikey if it was not already created
		'''
		if not os.path.isfile(self.project.biprivatekeyPath):
			print("Generating", self.project.bikeyName + ".bikey", "...")
			os.chdir(self.project.biprivatekeyFolderPath)
			subprocess.check_call([self.DSCreateKeyPath, self.project.bikeyName])
			shutil.move(os.path.join(self.project.biprivatekeyFolderPath, self.project.bikeyName + ".bikey"), self.project.bikeyPath)
			os.chdir(self.cwd)
			print("Bikey generated!")
	
	def postOnDiscord(self, channel, message):
		'''
		Posts the project as a zip-file on Discord
		'''
		pass
	
	def release(self):
		'''
		Releases the project on GitHub
		'''
		pass

if __name__ == "__main__":
	AddonBuilder()
